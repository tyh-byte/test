java概述
面向过程：（Pascal,C）关心过程，都是以什么正在发生为主要目标进行编程。面向过程是分析解决问题所需的步骤，然后使用函数逐步实现这些步骤。模块化思想。如公共汽车，面向过程关心的是汽车启动、汽车到站这些事件，而面对对象是关心汽车这个对象做了什么。到了编程就是
public class 汽车运营
{
	void 汽车启动{发生了什么} 
	void汽车到站（发生了什么）
}

面向对象：c++,c#,java,是一种理解和抽象显示世界的方法，由面向过程发展而来。对象的建立不是为了完成一个步骤，而是为了描述一个事务在解决问题的整个过程中的行为（抽象的）
public class 汽车
{
	void 到站（）{}
	void 启动（）{}
	
}

标准模板程序库是C++标准程序库的子集，包含容器、算法、迭代器、函数对象等。也有些人使用术语STL代表C++标准程序库。
使用C++标准程序库时，不必加上“.h”

快捷键
shift+f2  在网页中查该类的详细信息
f3  查该类的.class文件
ctrl+z  修复代码
ctrl+shift+f  格式化
ctrl+t  类层次
alt+/   代码提示
ctrl+k 查找相同的字段
ctrl+shift+b  断点
ctrl+o  显示大纲
shift+enter 新一行
alt+enter 当前.java文件的属性
1.1.1.4
       java ME SE EE  嵌入式应用 桌面应用 企业级应用
   .2
     特点：跨平台
           完全面向对象和简单性：不支持全局变量和宏替换，不支持goto语句，不支持指针类型，不支持结构类型，不支持头文件，内存动态存储且自动管理
           可靠性、安全性、多线程、支持分布式网络应用
   .3
     java核心技术：JDBC，JSP(动态网页技术标准)、JavaBean（对象组件技术）、JavaMail(提供E-mail邮件服务支持类库) 
   .4
     application应用：两种形式：application(控制台，用户界面) 和 applet（可嵌入web的最小应用）
1.2
   .1
   JDK:Integrated Development Environment,IDE
   jar:java archieve :java归档
   jdb：java调试器
   javac.exe java编译器
   java.exe java解释器
   src：source
   jre：java运行时环境
  
   javac *.java  编译文件
   java *.java   运行文件
   
   .2
   环境变量：path 指出可执行文件路径
             classpath 指出java包的路径

   .3
    包：类的集合，一个包中包含多个类，从存储方式看，包是类的组织方式，一个包就是一个文件夹，一个文件夹中 包含多个字节码文件
     .2
	java API 常用包  api （application programming interface,应用程序接口）
     .3
        引用包中的类包{.子包}.类|接口 [] 可重复0~1，{}可重复0~多
     .6
        导入包
        import 包{.子包}.类|接口|*；
         importy语句必须写在类声明之前 
     .7
        声明类所在包：package 包{.子包}
        package在源程序文件中只能写一次，且必须写在程序的第一行，即写在类声明之前，多
个类可以属于一个包
        没有main()方法则不能运行
     .9
       package--声明包，0~1句
       import---导入包，0~多
       public class或interface--声明公有类或接口 0~1，文件名与该名相同
       class---声明默认类 0~多
       interface--声明接口 0~多
 声明包的语句只能有一个，并且是第一条语句。声明为public的类或接口只能有一个，且文件名必须与该类名相同
     .10
        包可以压缩成JAR文件，JDK提供的文件压缩命令是jar.exe


1.3.1
     refactor 重构  navigate  导航
     在编辑器中，当类名或对象名后输入“.”时，自动出现代码提示窗口，按住ctrl键并单击类名或方法名时，可查看该方法声明
     常用视图；
              navigator:显示项目中的文件列表
              package explorer:显示项目中的包和文件
              outline：显示编辑器中的当前文件的方法声明，单击方法名可快速定位到指定方法
              hierarchy:显示当前类的继承关系
              problems：像是编译错误和警告信息
              console：显示控制台程序的运行结果
              tasks:显示代码中未完成的任务 
              debug:显示调试信息
              variables:显示调试过程的变量值    
    项目和工作区：workspace==》多个project==》java文件  .java
    通用功能的类，声明为public，可被其他应用程序引用
1.3.2
    创建项目-创建类
    创建java项目并运行
    可右键创建package-class  
    创建类可选择包含的方法  public static void main(string[] args)
    编辑、编译和运行
      执行主菜单edit下的（undo redo cut copy....）
      file下的open file save save as ....
      默认即时编译  project-build automatically,problems视图将同步显示编译错误
                 执行run  运行结果显示在console视图中
    重构
         refactor-rename可更改当前项目名或类名
     切换工作区
          file swith workspace  可选择另一个文件夹作为工作区
     导入项目
          file-import-general
     设置注释行
           source-toggle comment  toggle(触发器，开关)
     设置项目属性
           设置运行属性  run-run configurations-选中项目-设置运行的类、命令行参数等
                 一个项目可包含多个带有main()方法的类，可如上法设置运行的类（设置启动窗体）
                 在arguments的program arguments 编辑框中可输入命令行参数
           配制编译路径
                 右键-build path-configure build path-projeccts-add,配置后，访问其他类的权限就如同在当前包中
           添加JAR包
                在项目属性对话框的libraries上，单击add external jars  在jar selection 选择.jar文件
     设置环境属性
           window-preference  更新JDK、修改编辑区的字体和颜色、设置默认字符集等
                              更新JDK   -java-installed JREs-add- standard VM-next-directory
			      修改编辑区的字体和颜色：general-appearance-colors and fonts-basic-text font
                              设置默认字符集   general-workspace  默认GBK

1.3.3
     程序调试技术
        语法错（syntax error） 又编译错 标识符未声明、表达式中运算符与操作数类型不匹配、赋值时变量类型不兼容、括号不匹配、赋值时变量类型与表达式类型不兼容、括号不匹配、语句末缺少分号、else没有if
         语义错（semantic error） 又运行错 输入数据格式错，除数为0、变量赋值超出其范围、数组下标越界，一旦错误，将停止程序运行，在console视图中给出异常类和出错位置
         逻辑错（logical error） 如因循环条件错误导致没有运算结果、结果错误、或死循环等，运行系统对逻辑错没有识别能力
     .2
       程序运行方式：正常运行、单步运行、分段运行
       正常运行：run-run 直至程序结束，遇到运行错时，将终止运行，给出错误信息
       单步运行：step into:当运行到函数调用语句时，跟踪进入函数体内，对函数体进行单步调试
                 step over：将函数调用作为一条语句，一次执行完，不会跟踪进入函数体内
                 step return: 一次执行完函数体余下的语句序列，并返回到函数调用语句 
       分段运行：
　　　　　　　　run to line:运行至光标所在行
                resume：运行至下一个断点，将程序中的某一行语句设置为断点，当程序运行至断点时自动暂停。设置多个断点，把整个程序分成若干段
      .3
       调试过程
         设置断点：将光标设置在指定行，在行左边区域执行快捷菜单命令：toggle breakpoint 再次执行该命令，清除断点           
         调试界面：run-debug 到第一个断点暂停，执行window-show view 下的debug 和variable命令，打开相应视图，variables视图显示当前作用域内的变量值
          单步或分段运行：run-run to line  到光标  run-resume  到下一个断点暂停  run-terminate 停止调试，返回编辑状态，设置的断点依然有效
	  查看变量的当前值：variables视图显示的信息为当前作用域的变量值，自动改变
          附录 有照        


2 java语言基础
2.1.1 标识符与关键字
      toString 类名首字母大写，常量名全部字母均大写
2.1.2 基本数据类型
      两大类:基本数据类型（primitive）（8种、不可分解）和引用数据类型（reference types）（数组、类、接口）
      99l表示long型
      0123表示8进制 0x表示16进制
      unicode表示：\u0000~\uFFFF 如\u0041表示‘A’  \转义字符
2.1.3 变量与常量
       变量4要素：名字 类型 值 作用域
       最终变量 final 只能进行一次赋值
      
       常量：直接常量和符号常量
             直接常量；包括数值型和非数值型常量。
             符号常量保存在程序中不能被改变的数据，用关键字final声明  eg：final int MAX=100
2.1.4 运算符与表达式
       有字符串连接运算符“+”和instanceof，没有sizeof
       对象运算符  instanceof 判断一个对象是否属于指定类或其子类，运算结果是布尔类型
       左结合-操作数在运算符的左边  右结合-操作数在运算符的右边 从右边算
       布尔类型不是整数，true和false不能转换成数值1或0
       赋值相容：具有方向性，是不对称关系

2.2  流程控制语句
     顺序结构语句（赋值、空）、选择语句（if switch）、循环语句(while do-while for)、转移语句(break continue return)
     结构特点划分：简单语句、构造语句
2.2.1
    {}括起来的为块，是一条复合语句，其中变量的作用域仅限于该块
2.2.2
     if(bool表达式)    if while等语句中的条件表达式不能是赋值运算  如不可以是if(i=0)
         语句1；
     【else
          语句2；】
     
	//格式1?? ??? ?
?? ??? ?
	if(比较表达式){
?? ??? ??? ?
		语句体;
?? ??? ?
	}
?? ??? ?

	//格式2
?? ??? ?
	if(比较表达式){
?? ??? ??? ?
		语句体1;
?? ??? ?
	}else{
?? ??? ??? ?
		语句体2;
?? ??? ?
	}
?? ??? ?

	//格式3
?   分段函数? ??? ?
	if(比较表达式1){
? ? ? ? ? ? 
		语句体1;
?? ??? ?
	}
	else if(比较表达式2){
? ? ? ? ? ? 
		语句体2;
?? ??? ?
	}else if(比较表达式3){
? ? ? ? ? ? 
		语句体3;
?? ??? ?
	}
?? ??? ?
		...
?? ??? ?
	else{
?? ??? ??? ?
		语句体n+1
?? ??? ?
	}
如果 if 条件成立时的执行语句只有一条，是可以省略大括号滴！但如果执行语句有多条，那么大括号就是不可或缺的喽~~


     switch（表达式）
      {
         case 常量表达式1：语句序列1；[break;]
         case 常量表达式1：语句序列1；[break;]
          …………
         [default:语句序列;]
       }
2.2.3
    while(bool表达式)
          语句；

    do
    {
       语句；
     }while(布尔表达式)；

     for(表达式1;表达式2;表达式3)   此处无分号；
        语句；

2.2.4  循环体中无条件退出是一种很不好的习惯，不能作为程序设计的主流思想（break continue）

2.3  数组
   java的数组都是动态数组，用new运算符申请数组的存储空间
   声明方法：数据类型[]  数组变量  int[] a; int a[],i=0;i是int型变量
             数据类型  数组变量[]  inta[];  int[] a,i ；i是int[]变量
    使用new申请数组所需内存单元
     数组变量 =new 数据类型[长度]
     a=new int[5];声明时也可以申请：int a[]=new int[5];
     数组长度  数组变量.length
      各数据类型初值：引用：null  boolean:false  float：0.0f char:'\u0000'
     for语句作用于数组的逐元循环    获得数组中的每个元素
    for(类型 变量：数组)  for(int value:fib) system.out.print(""+value)
      数组的引用模型  b=a；b引用a拥有的数组，之后改变b同时a也会改变。 a==b为true ，复制a的话为false
2.3.2  二维数组
      int mat[][];
      mat=new int[4][5]; ==>int mat[][]=new int[4][5];
      mat.length  //返回二维数组长度，即行数
      mat[0].length //返回一维数组长度，即二维数组的列数
    不规则的二维数组
      int mat[][]=new int[3][] ;
      mat[0]=new int[3];
      mat[1]=new int[4];
      

2.4  静态方法
	静态方法是用来操作这个类型的，方法被该类的所有实例共享。
	而实例方法用来操作单个实例，不被该类所有实例共享。
	静态方法中不能调用实例方法，也不能访问实例变量。
	实例方法可以调用静态方法，也能访问静态变量。
	总之静态方法对应的是类型，即Class，类。但是实例方法对应的是实例，即object，对象
    java语言没有全局函数，函数声明在勒种，称为成员方法，有静态方法和实例方法两种
     方法声明与调用 
      声明格式：【修饰符】 返回值类型 方法（【参数列表】）【throws 异常类列表】
                 {
                       语句序列；
                       【return【返回值】】；
                  }

     修饰符：指定方法的访问权限等  如public static（声明静态方法）没有返回值用void标记
     java不支持类之外的全程变量
    调用：方法（【参数列表】）

     声明main方法；public static void main(string args[])
2.4.2  参数传递
      实际参数向形式参数传递原则：基本数据类型，传递值；引用数据类型，传递引用；方法体内，如果修改引用类型的形式参数，同时修改对应的实际参数
     
   	常量形式参数  用final声明  
	final int value[]  中value[0]是对的，可以更改常量数组元素值，value=new int[4]是错的

可变形式参数：在形式参数类型之后加...，表示该形式参数数目可变，可变形式参数只能用在最后一个形式参数位置，并且一个方法最多只能有一个可变形式参数。如 public static void print(int... value)//可变形式参数，可将value视为int[]类型，可将可变形式参数作为一个数组编程。

2.4.3 方法重载
      方法同名但参数不同
2.4.4 递归方法
      基本要素：边界条件 递推通式
 
2.5 字符串  string 是一个类，属于引用数据类型
    字符串常量 变量
     用单引号括起来的是字符常量，如‘a’；用双引号括起来的是字符串常量，如“a”，空串只有“”
  +=能够用于字符串变量，其他复合赋值运算符均不能用于字符串变量
      字符串不是数组  与c/c++不同之处
2.5.2  字符串类特性
       readLine();  关键System.in.read(buffer),从标准输入流读字节到缓冲区buffer，返回读取字节数
       throws java.io.IOException 抛出IO异常
       MyInteger.parseInt(string s),获得整数八、十、十六进制字符串表示的整数值
       MyInteger.toString(int value,int radix);返回整数的radix进制形式字符串   
    

3 类的封装、继承和多态
3.1 类和对象
   面向对象程序设计(OOP)
   类是描述对象的数据类型，刻画一组具有共同特性的对象
   类是静态概念、对象是动态概念
3.1.1
   成员方法、成员变量统称为类的成员

p.s:类是有class修饰，而方法（函数）是带有返回值void、int 等修饰的，类 实例用"."调用方法
     实例化类
   声明：【修饰符】 类<泛型> 【ectends 父类】 【implements 接口列表】
          修饰符：public abstract final
          泛型：类的类型参数，带参数的类称为泛型类，就像c++中的模板类
   成员变量声明：【修饰符】 数据类型 变量 【=表达式】{，变量【=表达式】}  修饰符：pulic protected private static final
   成员方法：【修饰符】 返回值类型 方法（【参数列表】）【throws 异常类列表】
             {
                  语句序列；
                 【return【返回值】】；
              }
   成员方法重载 参数列表不同，成员方法同名 参数不能指定默认值

3.1.2 对象
     类的实例  instance
     构造实例:MyDate d1= new MyDate(); 
new CodeBlock02() // 声明了之后不赋值，没有办法后续对这个对象继续操作
CodeBlock02 code = new CodeBlock02(); // 把声明的对象赋值给一个变量，可以进行后续操作
code 就是你用来接收 new 出的实例的的“遥控器”，它指向这个对象在堆区的具体位置。
     对象获得一个实例后：就可以使用点运算符.引用对象中的成员变量和调用成员方法 语法格式：对象.成员变量
     d1.month =10;//引用成员变量
     d1.set(2012，1,1)；//调用类的成员方法 
     对象引用模型：类是引用数据类型，一个对象引用一个实例，含义为对象保存该实例的引用信息

3.2  类的封装性
   封装是面向对象的核心特性，是信息隐藏思想的具体实现技术
   java提供构造方法、析构方法、方法重载、设置访问控制权限等措施对类进行封装
3.2.1  构造与析构
    构造方法与类同名 构造方法通过new运算符调用
    设定了构造方法后，java不再提供默认构造方法
    拷贝构造方法：指参数是该类对象的构造方法
    析构方法：java的析构方法声明如下：public void finalize()  一个对象也可以调用析构方法释放对象自己
3.2.2
    this引用：java的每个成员方法都可以引用该方法的调用对象 用法如下：
    1.指代对象  this   指代调用当前方法的对象
    2.访问本类的成员 变量和方法  this.成员变量  this.成员方法（【参数列表】）
    3.调用本类重载的构造方法 this（【参数列表】）
在构造方法中，this()必须是第一行语句。不能使用this调用当前的构造方法
  
对象的关系运算与比较相等
    =、!=  判断相等，是否引用同一个实例，没有<，<=等，不支持运算符重载
    java约定一个类的equals()方法用于比较该类的两个对象是否相等，包括引用同一个实例和分别引用两个实例
    instanceof对象运算符  判断一个对象所引用的实例是否属于指定类，运算结果是boolean型
    如：d instanceoof MyDate 
3.2.3 访问控制
   1.类的访问控制权限：公有和缺省  公有权限使用public修饰符可被所有包中的其他类访问
                        缺省权限没有修饰符，仅能被当前包（当前文件夹）中的其他类访问
   2.类中成员的访问控制权限
      1.private 只能被当前类的成员访问，这是类希望隐藏的部分
      2.没有修饰符或缺省权限  说明可以被当前类以及当前包中的其他类访问，也成为在当前包中可见
      3.protected 该成员能被当前类及其子类或当前包中的其他类访问，也称为在子类中可见
      4.public 声明公有成员，该成员可被所有类访问
   范围；当前类-当前包-其他包的子类-所有类  以上范围逐渐递增
      public等权限修饰符不能用于修饰方法体中的局部变量。因为局部变量的作用域仅限于当前方法，对其他类不可见，不存在其他类对它的访问
   3.声明set（）和get（）方法存取对象的属性
      成员变量设置为私有权限 声明公有成员方法，提供获得和设置各种属性的功能
 

3.2.4 静态成员
    静态成员属于类，即使没有创建实例，也可以通过类名访问静态成员变量和调用静态成员方法
    静态成员也可以通过对象引用
    在静态成员方法体重，不能访问实例成员，不能使用this引用  
    不能声明方法的局部变量为static
　　在声明时可对静态成员变量赋初值，也可使用ｓｔａｔｉｃ声明静态初始化块，对静态成员变量进行初始化，只能访问类中的静态成员，且不能引发检测性异常，在类加载时执行
　　static  //静态初始化块
    {
      静态成变量员初始化；
     }
    封装减少了外部程序对类中数据的依赖，这就是类的抽象性、隐藏性、和封装性
3.2.5 浅拷贝与深拷贝
    浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值   会影响被传递的对象
    当对象的成员变量是引用数据类型时，浅拷贝不能实现对象复制功能，需要深拷贝
    浅拷贝传递引用；深拷贝创建新实例
    当一个类包含引用数据类型的成员变量时，该类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用数据类型的成员变量创建新的实例，并初始化为形式参数实例值，这种复制方式称为深拷贝

3.3 类的继承性
    继承是面向对象的核心特性，是实现抽象和共享、构造可复用软件的有限机制
3.3.1 由继承派生类
   被继承的类称为父类或超类 新类称为子类或派生类 使用关键字extends声明一个类继承指定的父类
   格式：【修饰符】 class 类<泛型> 【extends 父类】 【implements 接口列表】
   java的类是单继承的，一个类只能有一个父类
3.3.2  继承原则及作用
    1.子类继承父类所有的成员变量
    2.子类继承父类除构造方法以外的成员方法
    3.子类不能继承父类的构造方法
    4.子类可以增加成员，可以重定义从父类继承来的成员，但不能删除他们
 object类  根类
    object类定义对象的基本状态和行为，它没有成员变量，提供一组供所有对象继承的方法
    当一个类没有声明父类时，java默认该类的父类是object。
  子类对父类成员的访问权限
    1.子类不能访问父类的私有成员，但可以调用父类的公有成员方法间接访问父类私有成员变量
    2.子类能够访问父类的公有成员public和保护成员
    3.子类对父类的缺省权限成员的访问控制，以包为界分两种情况
3.3.3 子类的构造方法
    可以使用“super引用”调用父类的构造方法  格式：super（[参数列表]）
   默认执行super()
    1.当一个类没有声明构造方法时，java提供默认构造方法，调用super()执行父类无参数构造方法
      一个类通常要声明无参数的构造方法，即使自己不用，也要为子类准备着
    2.如果子类的构造方法没有调用super()或this()，java将默认执行super()。

3.4 类的多态性
    方法的多态和类型的多态
    方法的多态包括方法的重载和覆盖，为一种功能提供多种实现；类型的多态表现为，子类是一种父类类型
3.4.1 子类重定义父类成员
     包括：1.重定义父类的成员变量，则隐藏父类的成员变量
           2.重定义父类的成员方法，如果参数列表和返回值类型均相同，则覆盖父类的成员方法；如果参数列表不同，则重载父类的成员方法。如果参数列表相同而返回值类型不同，编译器会指出存在二义性的语法错误
      在子类的实例成员方法中，可使用“super引用”访问被子类隐藏的父类同名成员变量，调用被子类覆盖的父类同名成员方法，语法格式如下：
           super.成员变量  //当子类隐藏父类成员变量时，引用父类同名成员变量
           super.成员方法  //当子类隐藏父类成员方法时，引用父类同名成员方法
     super将当前对象作为其父类的一个实例引用  注意：静态方法中不能使用super引用
    不能重载析构方法（没有参数）
3.4.2 类型的多态
   hasA  包含：eg. Person对象通过birthday成员变量引用一个Mydate对象
   isA   继承
    1.子类对象即是父类对象
    2.父类对象引用子类实例
      赋值相容 子类对象是父类对象；父类对象不是子类对象   Person p=new Student()；
    一个Object对象能够引用任何类的实例，如：Object obj =new Person();
    子类对象调用父类方法，参数可以为父类对象或子类对象
    一个类需要声明自己的equals（）方法，比较自己声明的各成员变量值
3.4.3  编译时多态和运行时多态
    1.编译时多态  在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态
      方法重载都是编译时多态，根据实参的数据类型、个数、次序，编译时可以确定
      方法覆盖表现出两种多态性，当对象引用本类实例时，为编译时多天，否则为运行时多态
    2.运行时多态
      当父类对象引用子类实例时，究竟执行谁的方法？
      程序运行时，java从实例所属的类开始寻找匹配的方法执行，如果当前类中没有匹配的方法，则沿着继承关系逐层向上，一次在父类或各祖先类中寻找匹配方法，直到Object类
3.4.4  多态的方法实现
     toString() 和equals()等方法被所有类继承
    1.多态的toString()方法
       一个类需要声明自己的toString()方法，覆盖父类或Object类的toString（）方法
    2.多态的equals（）方法
      1.子类扩展父类equals（）方法
      2.object类的equals（Object）方法
         比较两个对象是否引用同一个实例
      3.子类覆盖Object类的equals（Object）方法
         
3.5 类的抽象性
3.5.1 用继承刻画包含关系
3.5.2 抽象类
      使用关键字abstract声明的类，使用abstract声明的成员方法称为抽象方法
      抽象方法只有方法声明没有方法体
      抽象类不能被实例化   构造方法、静态成员方法不能声明为抽象方法
      包含抽象方法的类必须被声明为抽象类
      如果一个类声明继承一个抽象类，它必须实现父类的所有抽象方法，否则该类必须声明为抽象类
      抽象类用于描述抽象概念，抽象方法提供方法声明与方法实现的分离机制；子类继承抽象类的抽象方法，继承了父类的约定，子类可以根据自身的实际需要，给出抽象方法的具体实现，不同的子类可以有不同的方法实现。因此，一个抽象方法在多个子类中表现的多态性，使子类具有共同的行为能力
3.5.3  最终类
      用关键字final声明 不能被继承，没有子类 
       抽象类不能被声明为最终类
 声明最终方法：最终方法不能被子类覆盖，最终类中包含的都是最终方法。非最终类也可以包含最终方法
  public finaldouble areas()

4 接口、内部类和java API基础
    接口提供方法声明与方法实现相分离的机制，使多个类之间表现出共同的行为能力。接口机制使java具有实现多继承的能力。内部类使类具有嵌套结构

4.1 接口与实现接口的类  
       interface 是一组抽象方法、常量和内嵌类型的集合。接口是一种数据类型，接口采用抽象的形式来描述约定，因此接口只有别类实现之后才有意义
      一个接口可被多个类实现。接口声明的抽象方法在实现接口的多个类中表现出多态性
   1.声明接口
      【public】 interface 接口<泛型> 【extends 父接口列表】
       { 
            【public】【static】【final】 数据类型 成员变量=常量值；
            【public】【abstract】返回值类型 成员方法【（参数列表）】；
        }
      说明：1、接口中的成员变量都是常量，声明时必须赋值；不能声明实例成员变量
            2、接口中的成员方法都是抽象的实例成员方法，默认修饰符为public abstract，不能声明为static
            3、接口中不能包含构造方法，因为构造方法不能是抽象的
            4、接口的访问控制权限是public货缺省
            5、接口没有任何具体实现，也不能创建实例
  -able接口：表示一种对象属性，可.... ；其中Clonable、Serializable接口没有常量，也没有声明方法，称为标记接口，用于标记某个属性

2.声明实现接口的类

用关键字implements声明一个类实现指定接口，语法格式如下：
 【修饰符】class 类<泛型> 【extends 父类】 【implements 接口列表】
  一个类可以实现多个接口，多个接口之间用逗号分隔 
  一个接口通常约定某个性质，或做某件事；一个类声明实现指定借口，说明该咧具有这些接口约定的性质
  一个抽象类如果声明多个接口，则它必须实现（覆盖）所有指定接口中的所有抽象方法
方法的参数列表必须相同，否则它必须声明为抽象类
接口是多继承的
  一个接口可以继承多个父接口
接口是引用数据类型
  接口对象不能调用接口中没有声明的方法，否则语法错

接口与抽象类的区别
  从语法和作用上看，接口与抽象类很像，都是通过抽象的约定来定义类型，从而提供方法声明与方法实现分离的机制。
差别：
   1.抽象类为子类约定方法声明，抽象类可以处给出部分实现，包括构造方法等；抽象方法在多个子类中表现出多态性。类的单继承，使得一个类只能继承一个父类的约定和实现
   2.接口为多个互不相关的类约定某一特性的方法声明，在类型层次中表达对象拥有的属性。接口没有实现部分。接口是多继承的。一个类实现多个接口，就要多种特性，也是多继承的

单继承和多继承
 1.类的单继承的优点
      类和接口都是对类型的扩展
    接口为操作描述抽象的约定，没有实现。多继承，使得一个接口能够继承多个父接口的抽象约定
 2.接口的多态性
   接口多继承不存在二义性问题
3.类的多继承存在二义性问题

4.2 内部类和内部接口
  内部类和内部接口是声明在其他类或接口内部的内嵌类型，包含内嵌类型的类或接口称为外层类型  
  内嵌类型有两个目的：类型嵌套和对象嵌套 静态内嵌类型用于定义类型的嵌套结构，实例内嵌类型用于定义对象的嵌套结构
  内嵌类型是外层类型的成员，内嵌类型既有类型的特性，也有类中成员的特性

1.内部类作为类型的特性
  内嵌类型不能与外层类型同名
  内部类中可以声明成员变量和成员方法，内部类成员可以与外部类成员同名；内部接口中可以声明成员常量和抽象成员方法
  内部类可以继承父类或实现接口
  可以声明内部类为抽象类，该抽象类必须被其他内部类继承；内部接口必须被其他内部类实现

2.内部类作为成员的特性
  1.使用点运算符引用内嵌类型，语法格式：外层类型.内嵌类型
  2.内部类型具有类中成员的4种访问控制权限。当内部类可被访问时，才能考虑内部类中的成员的访问控制权限
  3.作为成员，内嵌类型与其外层类型彼此信任，能访问对方的所有成员
  4.内部接口总是静态的内部类可以声明时静态的或实例的，静态内部类能够声明静态成员，但不能引用外部类的实例成员；实例内部类不能声明静态成员
  5.在实例内部类中，使用以下语法格式引用或调用外部类当前实例的成员变量或实例成员方法
  外部类.this.成员变量
  外部类.this.实例成员方法

静态内嵌类型用于定义类型的嵌套结构
实例内部类用于定义对象的嵌套结构

4.3 Java API基础
4.3.1 java.lang包中的基础类库
1.object类
2.math数学类
  是最终类，不能被继承
3.comparable可比较接口
4.基本数据类型的包装类
5.string字符串类
6.StringBuffer字符串缓冲区类
7.class和package类
  this.getClass().getName()//返回当前对象所属类名字符串
8.system系统类
9.Runtime 运行时类

4.3.2 java.util包中的工具类库
1.日期类
date calendar gregoriancalendar
2.comparator 比较器接口
  约定多种比较对象大小的规则
  约定多种比较对象相等的规则
3.Arrays数组类
 排序
 二分法查找

4.4 泛型
  泛型（genericity）是对类型系统的一种强化措施，通过为类、接口方法设置类型参数，泛型使一个类或一个方法可在多种类型的对象上进行操作，从而减少数据类型的转换，避免类型转换的潜在错误，增强编译时刻的类型安全，增加软件可复用性，提高代码运行效率

1.泛型声明
  泛型指类、接口及方法声明的类型参数。带有泛型参数的类、接口及方法声明的语法格式如下，其中<>必需，通常使用单个大写字母作为类型参数，多个类型参数以逗号分隔
   【修饰符】 class 类<类型参数列表> 【extends 父类】 【implements 接口列表】
   【public】 interface 接口<类型参数列表> 【extends 父类接口列表】
   【public】【static】 <类型参数列表> 返回值类型 方法（【参数列表】） 【throws 异常类列表】
类型参数声明格式如下，其中，多个父类型以&连接
   类型变量 【extends 父类型列表】

2.泛型的必要性
 泛型T的实际参数必须是类，不能是int等基本数据类型

3.泛型的继承性及通配符
  Comparator<?>是所comparator<T>的父类型，？称为通配符
  泛型是必需的。它通过为类、接口及方法设置类型参数，对类型进行抽象，提供适用于更广泛类型的设计模板，增强编译时刻的类型安全，避免类型转换的麻烦和潜在错误。


5.异常处理
java语言的语法体系是严密的，语法检查是严格的，它在运行时能够捕获到所有运行错误：Java的异常处理提供语言级对运行时错误待处理机制；Java的内存自动管理提供内存资源使用的安全性。这些使得采用java语言开发的软件系统具有高度的可靠性、稳定性和容错性

5.1异常处理基础
5.1.1 异常处理机制的必要性
1.面向过程语言错误处理方式的缺陷  效率第一
  c语言不进行数据范围检查，数组下标越界时，系统不能识别错误 语义错演变成为逻辑错
2.面向对象语言的异常处理思想  正确可靠稳定比效率更重要
3.java语言是安全的

5.1.2 错误和异常
1.错误
指运行时遇到的硬件错误，或操作系统、虚拟机等系统软件错误，或操作错误
java.lang.error
2.异常
指在硬件、操作系统或虚拟机等系统软件运行正常时，程序产生的运行错误
例如：整数进行除法运算时除数为0，操作数超出数据范围，输入数据格式错误
非致命性的
java.lang.Exception
Error 和Exception 都是Throwable的子类
异常分为运行异常和非运行异常。运行异常是指由程序本身错误或数据错误所引发的异常，这类异常程序设计时大多可以避免；非运行异常是指由程序运行环境错误引发的异常，这类异常必须捕获并处理

3.RutimeException运行异常类
运行异常都是RuntimeException的子类
1.ArithmeticException 算术异常
2.NullPointerException 空对象异常
3.ClassCastException类型强制转换异常
4.NegativeArraySizeException负数组长度异常
5.ArrayIndexOutOfBoundsException数组下标越界异常
6.StringIndexOutOfBoundsException 字符串序号越界异常
7.NumberFormatException数值格式异常

4.程序对错误与异常的三种处理方式
1.程序不能处理错误。对于内存溢出等错误，由系统惊醒处理，java程序本身不能对错误进行处理
2.程序应避免而不捕获的异常。
3.必须处理的异常

5.2 异常处理措施
处理机制；异常类体系、异常处理的try语句、抛出自定义异常对象的throw语句、声明方法抛出异常的throws子句和自定义异常类
创建一个异常类对象的过程称为抛出（throw）异常
获得异常对象的过程称为捕获（catch）异常；由异常对象执行相应操作的过程称为处理异常，异常对象由捕获它的语句进行处理

5.2.1 异常处理语句
java提供try-catch-finally语句来捕获和处理一个或多个异常，语法格式如下，catch可以有多个，finally可以省略
try
{
<存在潜在异常的语句>；
}
catch
{
<捕获异常对象并进行处理的语句>；
}
finally
{
<最后必须执行的语句，无论是否产生异常，是否捕获到异常>；
}
如果所有catch子句都没有捕获ex，则ex将由java虚拟机捕获并处理，导致程序运行终止，就像没有使用try语句。因此，通常最后一个catch子句的异常类是Exception，能够捕获并处理所有异常对象

5.2.2 抛出异常
1.抛出异常对象的throw语句
一个异常对象可以由java虚拟机抛出，也可以由程序主动抛出
语法格式 ： throw  异常对象
2.方法声明抛出异常的throws子句
如果一个放阿飞产生异常，而该方法不想处理货不能处理该异常，则可以再方法声明时，采用throws子句声明该方法将抛出异常。格式如下：
  【修饰符】 返回值类型 方法（【参数列表】） 【throws 异常类列表】
throws子句的作用是，声明方法抛出指定异常，则方法的调用者必须捕获并处理该异常，这样实现了异常对象在方法之间逐级向上传递

5.2.3 定义异常类
java提供的异常类不能满足需要时，程序自定义异常类


第六章 图形用户界面  GUI
6.1 AWT 组件及其属性类
图形用户界面（GUI） java图形用户界面的组件和事件java.awt和javax.swing包共同提供，java.awt称为抽象窗口工具集
JDK1.1的委托事件模型取代了JDK1.0的层次模型。JDK1.2的Swing组件扩展了AWT组件的功能

6.1.1  AWT组件（abstract window tookit）
java.awt包主要由组件类、事件类、布局类、菜单组件类等组成
1.组件
是构成图形用户界面的基本成分和核心元素 
  组件是具有以下特性的对象：运行时可见，具有坐标位置、尺寸、字体、颜色等属性，可以拥有并管理其他组件，可以获得输入焦点，可以响应事件
  component是所有组件类构成树层次结构的根类，实际使用的组件都是component的子类
  一个组件在容器中的位置（x,y）是指组件左上角点相对于容器的坐标。容器的坐标系中，水平方向是X轴，垂直方向是Y轴
左上角点坐标是（0,0）

2.容器
  container 是一种特殊组件
  容器是一种特殊组件，它能容纳其他组件，在其可是区域内显示这些组件；一个容器中可以放置其他容器

3.窗口和面板
 窗口有标题栏和关闭控制按钮，有边框，可以添加菜单栏；窗口可以独立存在，运行时可以被移动、被改变大小。窗口是顶层容器，窗口不能包含在其他容器中。
 面板没有标题，没有边框，不可添加菜单栏；面板不能独立存在，必须包含在其他容器中，一个窗口可以包含多个面板，一个面板可以包含另一个面板。

4.框架和对话框
   window窗口类的子类有：frame框架和dialog对话框
   frame框架是一种框架，用作Java Application应用程序的主窗口，Frame带有最大化和最小化控制按钮
   对话框也是一种窗口，但不能作为应用程序的主窗口，它通常依附于一个框架，当框架关闭是对话框也关闭

5.标签Label
   标签组件用于显示字符串。便签只能显示信息，不能用于输入。

6.文本行 TextField
  文本行是一个单行文本编辑框，用于输入一行文字。

7.按钮 Button
按钮用于显示操作命令，执行一种特定操作
用户登录窗口
public class LoginFrame extends Frame {
	public LoginFrame() {
		super("User Login");//设置框架窗口标题
		this.setSize(200,130);//设置组件尺寸
		this.setLocation(300,240);//设置组件的显示位置
		this.setBackground(Color.lightGray);//设置组件的背景颜色
		this.setLayout(new FlowLayout());//设置容器为流布局，居中
		this.add(new Label("userid"));//创建标签，添加到框架上
		this.add(new TextField("user1",10));//创建文本行，10列
		this.add(new Label("password"));//
		this.add(new TextField(10));//创建10列的文本行
		this.add(new Button("Ok"));//创建按钮
		this.add(new Button("Cancel"));
		this.setVisible(true);//显示框架窗口
	}
	public static void main(String[] args) {
		new LoginFrame();
	}	
}
程序运行时，用户可以移动该窗口，改变窗口大小，但不能关闭，布局较乱，当窗口大小改变时，各组件的相对位置也随之改变

6.1.2 布局管理
Java采用布局管理器（layout manager）对容器中国的组件进行相对布局，当改变容器大小时，或者改变组件的大小，或者改变组件之间的相对位置，保证组件不会被遮盖并且容器没有空白区域
 Java提供多种风格和特点的布局管理器，每种布局管理器指定一种组件之间的相对位置。java.awt布局管理器主要FlowLayout流、BorderLayout边、GridLayout 网格和GridBagLayout网格包
  window窗口类的默认布局是BorderLayout,Panel面板类的默认布局是FlowLayout.如果一个容器需要改变其默认布局管理器，可以调用container容器类的setLayout()方法
1.流布局管理器
FlowLayou布局管理器提供按行布置组件方式，将组件从左至右顺序、一行一行地排列，当行放满时再放置到下一行。组件保持自己的尺寸，容器中一行的宽度随容器的宽度而变化

2.边布局管理器
BorderLayout布局管理器将容器划分为5个区域：东、南、西、北四条边和中间，add()方法省略位置常量，默认所有组件都放置在中部区域，后放置的组件覆盖先前放置的其他组件

3.网格布局管理器
将容器划分为大小相等的若干行乘若干列的网格，组件大小随容器大小而变化
GridLayout的组件放置次序是行优先，从第一行开始，从左至右依次放置，一行放满后自动转入下一行，每个组件占满一格。

4.网格包布局
GridBagLayout网格包布局是一种灵活的布局管理器，它将容器分成若干行和列网格，每个组件可占据其中的若干行或列的多个单元格

6.1.3 颜色和字体
1.颜色
color颜色类表示24位真彩色，color类声明white\black\red\yellow...等颜色常量，并提供以三原色值表示颜色的构造方法

2.字体
font字体类声明如下，一种字体由字体名、字形、字号的等属性组成

6.2 事件处理
6.2.1 委托事件模型
1.事件和事件源
事件（event）是指一个状态的改变，或者一个活动的发生。产生事件的组件称为事件源（event source）
2.事件类和事件监听器接口
java将事件封装成事件类，并为每个事件类定义一个事件监听接口（listener interface），约定事件处理方法，指定产生事件时执行的操作
一个图形用户界面的类声明实现一个事件监听接口，意味着该类将响应指定事件并提供事件处理方法。必须指明哪个组件要响应该事件
3.组件注册事件监听对象
一个组件能够响应的事件时有约定的，如按钮能够响应动作事件，窗口能够响应打开和关闭等窗口事件
 java在各组件类中声明了组件注册事件监听器方法，表示该组件要响应指定事件
 一个组件如果要响应多个事件，可以注册多个事件监听器；多个组件如果要响应痛一个事件，可以注册同一个事件监听器。这样，事件只传递给已注册的组件，不会被其他组件或容器获得。事件处理方法既可以由本类实现，也可以委托其他类实现，多个类可分工合作
UNICODE字符查询器
import java.awt.*;

import java.awt.event.*;

class QueryFrame extends Frame implements ActionListener {
	private TextField text_char, text_uni;
	private Button button_char, button_uni;

	public QueryFrame() {
		super("Unicode字符查询器");
		this.setBounds(300,240,280,90);
		this.setBackground(Color.lightGray);
		this.setLayout(new GridLayout(2,3,2,2));
		this.add(new Label("字符",Label.RIGHT));
		text_char = new TextField("汉字",10);
		this.add(text_char);
		button_char =new Button("查询Unicode码");
		this.add(button_char);
		button_char.addActionListener(this);//处理方法委托当前对象实现
		this.add(new Label("Unicode编码",Label.RIGHT));
		text_uni =new TextField(10);
		this.add(text_uni);
		button_uni=new Button("查询字符");
		this.add(button_uni);
		button_uni.addActionListener(this);
		this.addWindowListener(new WinClose());
		this.setVisible(true);
	}

	public void actionPerformed(ActionEvent ev) {
		if (ev.getSource() == button_char) {
			String str = text_char.getText();
			if (str.equals(""))
				return;
			char ch = str.charAt(0);
			text_char.setText("" + ch);
			text_uni.setText("" + (int)ch);
		} else if (ev.getSource() == button_uni) {
			String str = text_uni.getText();
			if (str.equals(""))
				return;
			int uni = Integer.parseInt(str);
			text_char.setText("" + (char)uni);
		}
	}

	public static void main(String arg[]) {
		new QueryFrame();
	}
}

class WinClose implements WindowListener {//实现窗口事件监听接口
	public void windowClosing(WindowEvent ev) 
	{
		System.exit(0);
	}

	public void windowOpened(WindowEvent ev) {}
	public void windowActivated(WindowEvent ev) {}
	public void windowDeactivated(WindowEvent ev) {}
	public void windowClosed(WindowEvent ev) {}
	public void windowIconified(WindowEvent ev) {}
	public void windowDeiconified(WindowEvent ev) {}	
}
窗口关闭事件是所有应用程序都要处理的事件，处理方式相同，可以委托其他类处理。
而按钮动作事件需要每个应用程序做特殊处理，不能委托其他类处理。

4.窗口关闭事件是所有应用程序事件驱动
1.不同组件的事件或同一组件的不同事件具有约定的质性次序
2.各组件的事件处理方法是否质性、执行次序以及执行次数，取决于用户操作
3.在一个事件处理方法中，按照语句次序顺序执行	

6.2.2 AWT事件类和事件监听器接口
1.AWT事件类
2.AWT事件监听器接口
  AWT事件监听器接口及其方法
 窗口事件、动作事件、鼠标移动事件、鼠标事件、键盘事件、焦点事件
3.AWT组件类中注册事件监听器的方法

6.3 Swing组件及事件
AWT组件不是跨平台的，从外观到控制都依赖本地从操作系统，称为重型组件。
为了实现图形用户界面的跨平台特性，java于JDK1.2推出swing组件，java建议用swing组件代替awt组件设计图形用户界面
swing组件是用纯java实现的轻型组件，没有本地代码，不依赖本地操作系统的支持。swing组件在不同操作系统上表现一致，并且有能力提供本地操作系统不支持的其他特性，支持可插入的外观感觉（Pluggable Look and Feel,PL&F）
swing是AWT库的扩展，所有swing组件都实现饿了accessible接口，支持可存取性；可以为swing组件设置多种边框；支持键盘操作；按钮、标签等组件能够添加图标对象
swing部分组件采用简化的MVC（model-view-controller，模型-视图-控制器）设计模式，组件包括视图和控制器功能，数据项则由一个相关模型存储和管理，提供插入和删除操作
swing组件在javax.swing包及其子包中，swing事件在javax.swing.event包中

6.3.1 swing组件与布局
1.swing组件类关系
JComponent是Swing轻型组件的根类，继承AWT的容器类java.awt.Container

2.Swing顶层容器
基于swing组件的图形用户界面，采用JFrame框架作为主窗口
JFrame和JDialog框架仍然是重型组件，不能直接将swing组件添加到JFrame和JDialog顶层容器中，而是要加到顶层容器包含的一个称为内容窗格的 （content pane）容器中，内容窗格是一个轻型组件

3.BoxLayout盒式布局和Box容器
BoxLayout 盒式布局管理器以水平或垂直方向放置组件，当改变容器大小时，多个组件将不会换行\列布局，而是调整组件大小仍然在一行\列排列
Box是使用BoxLayout的轻型容器

6.3.2文本显示和编辑组件及事件
1.标签 JLabel
增加功能：JLabel标签能够容纳一个Icon图形组件，这个特性体现了swing组件是容器
2.Icon 图标
Icon接口描述固定尺寸的图标，图标是一种图像，ImageIcon图标类实现Icon图标接口，用于从JPG或GIF图像生成图标
3.文本行和文本区
主要组件：JTextField JPasswordField JTextArea
JTextField 是单行文本编辑框，增加方法：水平对齐
JPasswordField 是JTextField J的子类，用于输入密码的一行字符串，以“*”代替
JTextArea 是一个显示纯文本的多行文本编辑框，它的基本操作与文本行类似，增加了接受换行符的多行控制
4.文本编辑组件响应的事件
  1.caretevent文本编辑事件
    当用户在JTextField  JTextArea 编辑时，每操作一个字符，将触发一次caretevent文本编辑事件
  2.actionevent动作事件
由于JTextField文本行中只允许输入一行内容，当用户按enter键时，将会触发ActionEvent动作事件。而JTextArea文本区允许输入多行内容，当用户按Enter键时，表示输入回车换行符，所以不会触发动作事件。如果要在JTextArea文本区输入完成后对内容进行处理，可添加按钮，通过按钮的动作事件进行处理

类.this 当前外部类实例  外部类的当前对象eg. 对话框所依附的当前窗口Frame.this==>Frame.Dialog

5.微调文本行组件及事件
JSpinner微调文本行组件在文本行编辑框右边带有一对上、下的箭头按钮，它既可以直接输入，也可以使用箭头按钮从一个有序序列中微调选择一个取值，键盘的上下方向键也可用于选择序列值

6.3.3 按钮组件
包括JButton按钮与选项按钮 组件JCheckbox JRadioButton 
1.按钮
JButton  增加功能：JButton表面可以带图标
2.复选框  方框
一组数据项中各项之间没有联系
JCheckbox 实现多项选择
3.单选按钮 圈点
一组数据之间各项之间有联系
一旦重新选择了一个数据项，则先前被选中的数据项随即自动变为“没选中状态”
JRadioButton
只有在同一个按钮组的多个单选按钮的选中状态才是互斥的
需要由JRadioButton类和ButtonGroupanniu 组共同实现
4.抽象按钮类
AbstractButton抽象按钮类定义按钮和菜单项的一般行为
AbstractButton的3种按钮都可以注册动作事件监听器。当用户单击复选框或单选按钮时，将改变它们的状态，触发ActionEvent事件

6.3.4 列表框和组合框
当可供选择的数据项较少且数据项名称和数目确定时，通常使用复选框和单选按钮，当数据项较多时，通常使用JList列表框或JComboBox组合框组件
1.列表框及其事件
  1.JList列表框
    该组件能够容纳并显示一组数据项，从中选择一个或多个数据项，默认为多项选择。JList的数据项具有线性关系，每个数据项对应一个序号（大于等于0）
  2.列表框模型
     JList的数据项由列表框模型存储并管理，数据项具有线性关系，有次序且元素可重复。当改变列表框模型中的数据项时，自动更改JList的显示
  3.列表框选择事件
     选中列表框的数据项，触发ListSelectionEvent列表框选择事件

2组合框 
JComboBoxz组合框由一个文本行和一个列表框组成，表现为一个右边带向下箭头的文本行，组合框既可以像文本行一样直接输入数据，也可以像列表框一样选择数据项，只是列表框平时是隐藏的，当用户单击箭头时，才显示列表框
 1.JComboBox组合框
    JComboBox类声明如下，包括构造、选中、注册事件监听器等方法
 2.组合框响应动作事件
    在组合框的下拉列表中选择数据项；或当组合框可编辑时，在文本行中按enter键，都触发ActionEvent事件

6.3.5 中间容器
1.滚动窗格
 JScrollPane 滚动窗格是带有滚动条的视图容器，用于为其他组件提供可滚动视图。JScrollPane自动管理垂直和水平滚动条，只要组件内容超过视图大小就会自动显示水平或垂直滚动条
  JTextArea JList 等组件没有带滚动条，可以将它们放置在JScrollPane滚动窗格中
2.分割窗格
 JSplitPane 分割窗格是包含两个组件的容器，组件之间有分隔条，拖动分隔条可以改变组件的大小，
 垂直分割时，两个组件从左到右排列；水平分割时，两个组件从上到下排列
 如果希望分割两个以上的组件，则可以采用多个嵌套的分割窗格

6.3.6 JOptionPane和JColorChooser对话框
1.JOptionPane 选项对话框
  JOptionPane定制多种形式的标准对话框，消息、确认和输入对话框
   "\""----代表一个双引号
2.JColorChooser选择颜色对话框
  
至于接口能不能new出来，说不能，是因为不能像用new实现类那样new出来，说能，是因为你用new必须要在这条语句中实现这个借口的所有方法

package contract;
public interface ISay {
     void sayHello();
 }


package jimmy;
import contract.ISay;

public class Program {
    
	public static void main(String[] args) {
        
		ISay say = new ISay() {          
            
			public void sayHello() {
                
				System.out.println("Hello java!");
            
			}
        
		};
    
	}

}

初看上去，就好象在“不提供接口实现的情况下，直接new了一个接口实例”。

观察bin目录下的class输出，会发现有一个类似Program。

class文件，如果反编译观察一下，发现原来是编译器自动生成一个类program

一个文件只能有一个public的类或interface

private static Equalable<?> equal[] = { new EqualName(), new Equalbirthday() };// 见例4.4
private static Comparator<?> comparators[] = { new CompareName(), new CompareBirthday() };
当不知道什么类实现了equalable<T>时，T用？代替，应该是哪个类实现了这个接口<>里就用哪个类



6.3.7 菜单组件
1.使用菜单的两种方式
  1.窗口菜单
    JMenuBar菜单栏、JMenu菜单，JMenuItem菜单项组件组成，窗口上添加菜单栏，菜单栏中添加菜单，菜单中添加菜单项或子菜单，这样形成了窗口菜单的多层结构。菜单栏添加在窗口上方，不受布局管理器控制
  2.快捷菜单
    快捷菜单相对于组件的，当鼠标指向某个组件时，单击鼠标右键，弹出的菜单称为快捷菜单。快捷菜单也是由若干 菜单项组成的，其结构相对简单，通常最多只有二级子菜单
2.菜单栏
  JMenuBar菜单栏是窗口中用于容纳JMenu菜单的容器
3.菜单
  JMenu菜单是一组JMenuItem菜单项或子菜单的容器，每个菜单带一个标题
  菜单提供add（）方法添加菜单项或子菜单。如果一个菜单中加入另一个菜单，则构成二级子菜单
4.菜单项
  JMenuItem菜单项是组成菜单或快捷菜单的最小单位，不可分解。
5.选择菜单项 
  复选菜单项和单选菜单项
  与JRadioButton单选按钮一样，一组单选菜单项也要包含在一个ButtonGroup按钮组中
6.快捷菜单
不添加在菜单栏上，依附于一个组件；用户单击鼠标时显示；不受布局管理器控制，显示快捷菜单时，必须指定其位置
7.工具栏
JToolBar工具栏是一种容器，其中可添加组件，可拖动约定放置在窗口上方
  运行时，当工具栏的拖动属性为true时，按住工具栏的标志块，可将工具栏拖动至窗口的四边，也可呈浮动状态

6.3.8 表格
1.JTable表格
  以表格形式显示多行数据项，每行由多列数据项组成。多行数据项呈线性次序，行号>=0.双击表格中的单元格，即可修改表格内容。JTable没有带滚动条
2.表格模型
  JTable数据项的存储及管理操作由表格模型类提供。javax.swing.table.TableModel是表格模型接口，DefaultTableModel是实现该接口的默认表格模型类，声明

6.4 图形图像
  图形：矢量图形（Graphics）
  图像：映像，输出时，以数字方式控制显示设备实现原来景物的重现，图像文件的格式有BMP\JPG\GIF等

6.4.1 图形设计
1.坐标点类
  java.awt.Point
2.图形类
  java.awt.Graphics
3.组件绘图方法
  java.awt.Component中
        public void paint(Graphics g)
        public void repaint()
        public void update(Graphics g)
4.画布
  通常在画布上绘制图形。java.awt.Canvas  画布组件用于绘制图形

6.4.2 图像
1.image图像类
  java.awt.image图像类是抽象类，提供获得绘图对象、图像缩放等功能
2.Graphics支持显示图像
  java.awt.Graphics提供显示图像drawImage()方法
  显示图像的组件必须实现java.awt.image.ImageObserver图像观察器接口，由于Componet类实现了ImageObserver接口，所以所有组件都可以作为图像观察器来显示图像

第七章 多线程
7.1 操作系统中的进程与线程
1.进程  
  是一个程序关于某个数据集合的一次执行过程，是操作系统进行资源分配和保护的基本单位
  特性：结构性、独立性（是系统调度的独立单位）、动态性、并发性、交互性
2.线程
1.引入线程机制的动机和思路
  基本思路：把进程的两项功能--“独立分配资源”和“被调度分派执行”分离，前一项仍由进程完成，后一项任务交给线程的实体完成；这样，进程作为系统资源分配与保护的独立单位，不需要频繁的、地切换；线程作为系统调度和分派的基本单位，会被频繁地调度和切换
2.线程的定义和特性  
  线程（thread）是进程中能够独立执行的实体（控制流），是处理器调度和分派的基本单位。线程是进程的组成部分，每个进程内允许包含多个并发执行的线程。同一进程中的所有线程共享进程获得的内存空间和资源，但不拥有资源
  支持多线程的进程称为多线程进程
线程的特性：结构性（是操作系统调度的基本单位）、动态性、并发性共享性
3.线程的状态
包括：新建、就绪、运行、阻塞、终止
4.线程调度
  采用剥夺方式；
  常用：高优先级线程剥夺低优先级线程运行；二是当运行线程时间使用完后被剥夺处理器

3.并发程序设计
  顺序程序设计（sequential programming）：程序模块按语句次序顺序执行；
特性：执行的顺序性、运行时的封闭性、执行结果的确定性、计算结果的可再见性
  并发程序设计（concurrent programming）：将一个程序分成若干可同时执行的程序模块，每个程序模块和它执行时所处理的数据集合组成一个进程，因此，一个程序在运行时由并发执行的多个进程共同完成指定任务。一个进程中有包含多个并发执行的线程，操作系统以进程作为系统资源分配的基本单位，以线程作为系统调度的基本单位。特性如下：1、不具顺序性，由操作系统调度
                        2、运行环境不再是封闭的，一个线程的执行可能影响其他线程的执行结果，因此，程序的运行结果具有不确定性，计算过程具有不可再现性
                        3、共享变量的多个线程（称为交互线程）之间实现线程通信，能够写作完成一个任务，也会出现与时间有关的错误。因此，必须对并发执行的交互线程进行有效控制，协调它们并发执行的次序和相对速度，确保互斥地访问共享变量以及通信同步，保证运行结果正确
                        4、并发多线程程序设计的优点是,提高了系统性能，具体表现为快速切换线程、减少系统管理开销、线程通信易于实现、并发程度高、节省内存空间等

7.2  Java线程对象
java支持内置多线程。java语言包中的Ruannable接口约定线程的执行方法，Thread类提供创建、管理和控制线程对象的方法

7.2.1 Ruannable接口与Thread类
1.Ruannable接口
   只声明了run()方法，是线程的执行方法  一个线程对象必须实现run()方法以描述该线程的所有活动以及执行的操作，已实现run()方法称为该线程对象的线程体
2.Thread线程类
  具有封装线程对象的能力
  线程对象由Thread或其子类声明。构造线程对象时，可为其指定线程名；如果没有指定线程名，java将提供一个线程名
   线程对象执行run()方法，该run()方法既可以由线程自身提供，也可以由目标对象提供，目标对象指实现了Runnable接口的对象
   java提供两种方式实现多线程程序设计：继承Thread类和实现Runnable接口

e.g  声明继承Thread类的奇数/偶数序列线程

//首先执行的线程是main,主线程，此程序包含3个线程，并发地执行，main线程优于其他线程执行
线程启动语句的顺序不能决定线程的执行次序。线程启动后处于就绪状态，等待操作系统调度执行，线程何时执行、线程执行次序以及是否被打断均不由程序控制。如果线程执行时间过长或其他原因，线程执行将被中断，等待再次调度执行。因此，线程的运行结果具有不确定性。本例中，当输出序列较长时，奇数线程和偶数线程交替运行，交替输出序列值（线程启动了，只是不会从头开始运行，但可能被打断）

Thread类声明带有Runnable接口对象的构造方法
   public Thread(Runnable target)  //target指定线程的目标对象，接口类型
声明一个对象实现run()方法可以作为一个线程对象的目标对象，为一个线程对象提供线程的执行的run()方法
Thread的子类声明非空的run（）方法覆盖Thread类的run（）方法，其对象执行的是自己的run（）方法，不需要目标对象

3.两种创建线程方式的比较
   前两例分别使用两种方式创建线程，效果相同，那么，在实际编程中如何选用这两种方式呢？
  1.继承Thread线程类。  缺点是不适用于多继承
  2.实现Runnable接口。当一个类已继承一个父类，还要以线程方式运行，就要实现Ruannable接口，作为线程对象的目标对象使用，需要同时声明一个Thread线程对象

7.2.2 线程对象的优先级
 Java提供10个等级的线程优先级，分别用1-10，优先级最低为1，最高为10，默认值是5.
 public final int getPriority  //获得线程优先级
 public final int setPriority(int priority)   //设置优先级
拥有更高优先级的线程能够更快地进入运行态

7.2.3 线程对象的生命周期
1.Thread.State类声明的线程状态
  Thread.State是Thread类的内部枚举类，其中声明6中线程状态，声明如下：
  新建态、运行态、阻塞态、等待态（等待时间不确定）、等待态（等待时间确定）、终止态
导致线程进入阻塞态（BLOCKED）或等待态的原因有多种，如输入\输出、等待消息、睡眠、锁定等。
终止态（TERMINATED） 原因：运行结束或被强行终止
2.Thread类中改变和判断线程状态的方法
  start（）启动新建态的线程对象，一个线程只能启动一次
  sleep()线程睡眠。使当前线程停止执行若干毫秒，线程由运行态进入等待态，睡眠时间到，线程可再次进入运行态。
  interrupt（）线程中断，设置运行中断标记，与之配合使用的还有判断线程是否中断的方法，此方法为当前线程设置一个中断标记，以便于run()方法运行时使用isInterrupted（）方法能够检测到，此时，线程在sleep()之类的方法中被阻塞时，由sleep()方法抛出线程中断异常，可捕获这个异常进行中断处理操作
注意：interrupt（）方法只是为线程设置了一个中断标记，并没有中断线程运行，该方法没有抛出异常，一个线程在被设置了中断标记之后仍可运行。isAlive()返回true。实例方法isInterrupted（）测试线程对象的中断标记，并不清除中断标记
当抛出一个InterruptedException异常时，记录该线程中断情况的标记将会被清除，这样再调用isInterrupted（）返回false

eg. 7.3 设计滚动字演示线程状态及改变方法
  线程启动后执行run()方法，将字符串原第0个字符连接到字符串最后，通过线程睡眠控制字符串显示一段时间，再次重新循环移位字符串，达到人眼看起来像是字符串在移动的效果。
     str.substring(1)+str.substring(0,1)//从右到左

7.2.4
  定时器与图形动画设计
动画（animation）都是利用人眼的视觉特性形成的。
图形动画设计的原理是，在画布上绘制一幅图，停留一点时间后，用画布背景色重画这幅图，就擦掉了原图；错开一些位置重画图形并停留一点时间，再擦除、重画，反复执行，从人的视觉效果来看，就好像图形在移动
  动画设计需要使用线程技术，利用线程对象睡眠来控制画图和重画时间，睡眠时间长则移动较慢，反之移动较快。当需要周期地执行某些操作，除了使用线程外，还可以使用swing的timer组件
  timer许建实现定时器功能，一个timer对象，每隔delay时间，执行actionevent事件
 EG.7.4 弹弹球，使用定时器实现图形动画

7.3 线程的同步机制
  如果并发执行的多个线程间需要共享资源或交换数据，则这一组线程称为交互（interaction）线程。交互线程并发执行时相互之间会干扰或影响其他线程的执行结果。因此，交互线程间需要有同步机制
  交互线程存在两种关系：竞争关系和协作关系。对于竞争关系的交互线程需要采用线程互斥方式解决共享资源冲突问题，对于协作关系的交互线程间需要采用线程同步方式解决线程间通信及因执行速度不同而引起的不同步问题。线程的同步机制包括线程互斥和线程同步，线程互斥是线程同步的特殊情况

7.3.2 交互线程
1.无关线程与交互线程
  无关的并发线程在不同的变量集合上操作，即一个并发线程不会改变另一个并发线程的变量值
  交互的并发线程指他们共享某些变量一个线程的执行可能影响其他线程的执行结果，交互的并发线程之间具有制约关系。因此，线程的交互必须是有控制的，否则会出现不正确的结果。
2.并发执行的交互线程间存在与时间有关的错误
  交互的并发线程执行时，由于它们在不同时刻对同一个共享变量进行操作，线程之间相互影响，相互干扰，因此计算结果往往取决于这一组并发线程的相对速度，各种与时间有关的错误就可能出现

例7.5  并发执行的 多个存/取款线程存在与时间有关的错误

run()方法中国即使没有sleep(1)语句，线程也可能会被打断
避免错误的方法：多个线程串行、互斥地访问共享变量

7.3.2 线程间的竞争关系与线程互斥
1.线程间的竞争关系
极端情况，被阻塞线程永远得不到访问权，从而无法成功地终止
   死锁：一组线程如果都获得了部分资源，还想得到其他线程所占用的资源，最终所有的线程将陷入死锁
   饥饿：一个线程优于其他线程总是优于它而被无限期拖延。
2.线程互斥和临界区管理
  线程互斥（mutual exclusion）是解决线程间竞争关系的手段。
  把共享变量代表的资源称为临界资源（critical resource）,并发线程中与共享变量有关的程序段称为临界区（critical section）。
操作系统对共享一个变量的若干线程进入各自临界区有以下三个调度原则：
  一次至多一个线程能够在它的临界区
  不能让一个线程无限期地留在它的临界区
  不能强迫一个线程无限地等待进入它的临界区。特别地，进入临界区的任一线程不能妨碍正等待进入的其他线程的进展
总结为四句话：无空等待、有空让进、择一而入、算法可行
   操作系统提供“互斥锁”机制实现并发线程互斥地进入临界区，对共享资源进行操作。至于操作系统采用什么样的锁（信号灯、只读锁等）以及如何实现加锁和解锁等问题，java程序员并不需要关心，这些细节都由操作系统和java虚拟机处理好了，程序员只需要在程序中声明哪个程序段是临界区即可，采用java抽象的锁模型，就能够使程序在所有平台可靠地、可预见地运行

3.java的线程互斥实现
  java提供关键字synchronized用于声明一段程序为临界区，使线程对临界资源采用互斥使用方式。两种用法：声明一条语句，或者声明一个方法
  1.同步语句
	synchronized声明一条语句为临界区，该语句称为同步语句，格式如下
             synchronized（对象）
                语句
“对象”是多个线程共同操作的公共变量，即需要被锁定的临界资源，他将被互斥地使用《语句》是临界区，描述线程对临界资源的操作
  2.同步方法
     使用synchronized声明一个方法，该方法称为同步方法，语法格式如下：
 	synchronized  方法声明
   同步方法的方法体称为临界区，互斥使用（锁定）的是调用该方法的对象。该声明与以下声明效果相同：
              方法声明
              synchronized（this）
              {
                  方法体
              }
同步语句与同步方法的行为基本相似，只是前者的作用范围小，它只是锁住一条语句（或复合语句）而不是完整的方法

7.6 互斥的存\取款线程设计
  运行临界区的代码，即使线程执行被打断，也不释放对象锁，只有当线程执行完才释放对象锁。这样不仅使得任何时刻只有一个线程对同一个账户进行操作，而且保证每个执行的多个操作时连续的，期间不会被其他线程干扰。

7.3.3 线程间的协作关系与线程同步
1.线程间的协作关系
  知道其他线程的存在，而且受其他线程执行的影响。当合作线程中的一个到达协调点后，在尚未得到其伙伴线程发来的信号之前应阻塞自己 ，知道其他合作线程发来协调信号后方 被唤醒并继续执行。这种协作线程之间相互等待对方消息或信号的协调关系称为线程同步。
例 7.7 发送线程与接收线程
  
2.线程同步
 是解决线程间协作关系的手段。线程同步（synchronization）是指两个以上线程基于某个条件来协调它们的活动。一个线程的执行依赖于另一个协作线程的信号，当一个线程没有得到来自于另一个 线程的信号时则需等待，直到信号到达才被唤醒
   线程互斥是一种特殊的线程同步，即逐次使用互斥共享资源，也是对线程使用资源次序上的一种协调

3.线程同步机制
  操作系统实现线程同步有一种工具称为信号量和PV操作，它的指导思想源于采用多种颜色信号灯管理交通的方法，描述如下。
1.背景
  多个线程需要对同一个共享变量进行操作，所以多个线程间必须互斥地执行，即这些操作方法必须是互斥的
2.设置信号量
  为这些共享变量约定一个信号量（semaphore），设置信号量有多种状态，就像是交通信号灯一样。设置信号量状态有多种方式，既可以由两种状态，也可以有多种状态。两种状态用bool值即可；多种状态表示一种轮流执行方式，如n=i时，约定执行i线程
   测试信号量状态的操作称为P操作，改变信号量状态的操作称为V操作，这两种操作时互斥的，并且执行时不能被打断
3.线程根据信号量状态而执行
  多个线程间彼此根据信号量的状态确定该执行谁，当一个线程开始执行时，它先要测试信号量的状态，如果状态合适，则执行，进行相关操作并更改信号量状态，唤醒其他等待线程执行；否则等待，使线程自己处于阻塞状态，直到唤醒再次执行。
  这样，交互的并发线程之间通过交换信号来达到调整相互速率，保证线程协调运行的目的。利用信号量和P，V操作既可以解决并发进程的竞争问题，又可以解决并发进程的协作问题。

4.java的线程通信方法
  java.lang.Object类提供wait(),notify()和notify()All()方法实现线程间通信
     notify（） 唤醒一个等待线程
 这些方法可以被任意类的对象调用，并且声明为最终方法

例7.8 采用信号量和同步方法使发送线程与接收线程同步运行
在互斥的put和get方法中国，如果只有wait方法而没有notify（)方法，则线程死锁
例7.9 发牌

第8章 输入/输出流和文件操作
文件是信息的一种组织形式，是存储在外部存储介质上的具有标志名的一组相关信息集合。
流是指一组有顺序、有起点和终点的字节集合，是对数据传输的总称或抽象。
在java.io包中

8.1 文件和流
8.1.1 操作系统中的文件和目录概念
1.文件与文件系统
保存性
文件系统提供“按名存取”实现文件的存储和检索。
在操作系统中，对设备的访问也都是基于文件进行的
2.目录结构与文件检索
文件系统提供目录机制实现文件的“按名存取”。目录（directory）是文件系统组织和管理的基本单位，目录中保存它所管理的每个文件的基本属性信息（称为文件目录或文件控制块）
目录子目录具有层次关系。顶层的是根目录。树状结构。文件是这种树状结构的叶子节点，文件中不能包含另一个文件
在多级树状目录结构中，一个文件的全名由该文件的路径名和文件名组成。文件名是区分文件的唯一标志。
在windows系统中，目录也称为文件夹
3.文件的逻辑结构
文件是文件系统中最小的数据组织单位，目录机制提供文件之间的分类和组织方式。
文件组织包括两方面：逻辑结构和存储结构。
按逻辑结构可分为两大类：流式文件和记录式文件
   流式文件由字节序列或字符序列组成。如源程序、文本文件等是字符流式文件
   记录式文件是一种有结构的文件，包含若干记录。记录式文件内独立的最小信息单位，记录可进一步划分成若干个更小的数据项（item），是具有标志名的最小的不可分割的数据单位。数据项的集合构成记录，相关记录的集合构成文件。如学生基本信息文件，每个学生信息为一个记录，文件由若干学生记录组成，每个记录又可由学号、姓名、性别等数据项组成
   流式文件也可以看成是每个记录只有一个数据项的记录式文件，而任何记录式文件都可以看成是以字节为单位的流式文件
4.文件的存取方式
   1.顺序存取是指按记录顺序进行读写操作的存取方式。
   2.随机存取是指按记录序号进行读写操作的存取方式。
   3.索引存取。是基于索引文件的存取方法  按记录键来编址
5.文件的使用方式
  针对用户和应用程序两种不同的对象，操作系统通过操作接口和应用程序接口两种方式提供其功能和服务，对文件系统亦是如此
  1.操作接口：操作系统将其功能和服务以操作命令形式提供给用户，用户以手动方式对文件系统等进行操作，实现人机交互功能。文件操作命令包括MS-DOS系统提供的md cd dir type等命令；windows系统提供的资源管理器窗口作为管理文件和目录的图形用户界面，用户在其中使用鼠标以手动方式进行创建文件夹、打开文件夹、移动文件夹等操作
  2.应用程序接口（API）：操作系统将其功能和服务以系统调用（system call）形式提供给应用程序。所有用户操作能够实现的功能都能通过系统调用在应用程序中实现
  程序设计语言通常将系统调用设计成库函数，目的是隐藏操作系统内部结构和硬件细节使系统调用更像函数调用。应用程序通过调用库函数就可以访问系统管理各种软硬件资源，调用操作系统功能，获得操作系统提供的服务

8.1.2 流的概念
1.流的定义和作用
 1.流的定义、方向、和读/写操作
   流（stream）是指一组有顺序、有起点和终点的字节集合，是对数据传输的总称或抽象。换言之，数据在两个对象之间的传输称为流
   数据流动具有方向，由外部输入流向内存，称为数据输入；内存向外部输出设备，称为数据输出。按期方向，分为输入流和输出流
  流的基本操作由读操作和写操作，从流中取得数据为读，向流中加数据叫写。一个流只能进行读或写中的一种操作，或者读或者写，不能同时读和写。对输入流只能读，对输出流只能写。
 2.流采用缓冲区技术 
   提高数据传输效率，将一块内存空间设计成缓冲区（buffer），暂时存放待传送的数据。以数据块形式传送，能显著地提高数据传输效率。配备缓冲区的流称为缓冲流（buffered stream）
  写入数据时，系统将数据发送到缓冲区，而不是直接发送到外部设备。缓冲区自动记录数据，当缓冲区满时，系统将数据全部发送到相应的设备。如果在缓冲区写满之前就要进行数据传输，称为立即传输（flush）操作。当缓冲区空时，系统就会从相关设备自动读取数据，并读取尽可能多的数据充满缓冲区
 3.流的作用
   设计流的目的是使数据传输操作独立于相关设备。程序需要根据待传输数据的不同特性而使用不同的流，数据传输给指定设备后的操作由系统执行设备驱动程序完成。这样程序不需要关注设备实现细节，使得一个源程序能够拥有多种输入/输出设备，从而增强程序的可重用性。

2.流的存在
  以下四种情况存在数据流动问题
  1.控制台应用程序的标准输入/输出操作。
  2.文件读写操作。读文件操作存在输入流，数据从磁盘流向内存；写文件操作中存在输出流，数据从内存流向磁盘
  3.线程通信。数据从一个线程对象（内存）流向另一个线程对象(内存）
  4.网络通信。数据从一台计算机的一个进程（内存）通过网络流向另一台计算机的一个进程（内存）
3.java的流类和文件类
按照流中元素的基本单位:流可分为字节流（binary stream）和字符流（character stream）。按照流的方向性，流可分为输入流和输出流。每种流类都有输入流和输出流两个类
   1.字节流以字节为单位读/写流，用于传输非字符数据，如整数，浮点数，对象等。InputStream和OutputStream是字节输入/输出流的根类
   2.字符流以字符为单位读/写流，仅用于传输字符，包括各种字符集。Reader和Writer是字符输入/输出流的根类。
  file文件类挤在文件属性信息，RandomAcessFile随机存取文件类以随机存取方式进行文件读/写操作。

8.2 字节输入/输出流类
 最小单位1字节。
8.2.1 抽象字节流
1.InputStream 
  read()抽象方法每次从输入流中读取1字节，返回读取的该字节。read(byte[])方法每次读取若干字节到指定缓冲区buffer，返回实际读取的字节数
2.OutputStream

  
 





































































